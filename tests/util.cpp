#include <cstdio>
#include <iostream>
#include <fstream>
#include <gtest/gtest.h>
#include <rhoban_utils/util.h>

/**
 * Check if two vector of string contains same element, in same order.
 */
bool vectorAreIdentical (std::vector<std::string> vector1, std::vector<std::string> vector2) {
    if(vector1.size() != vector2.size()) {
        return false;
    }
    
    for (std::vector<int>::size_type i = 0; i < vector1.size(); i++) {
        if(vector1[i] != vector2[i]) {
            return false;
        }
    }
    return true;
}

/*******************************************************
 * Tests rhoban_utils::split
 */

// Return true if the split has work.
bool test_split(std::vector<std::string> words, char delimiter) {
    std::string s = "";
    for (std::vector<int>::size_type i = 0; i < words.size(); i++) {
        s += words[i];
        if (i < words.size() - 1) {
            s += delimiter;
        }
    }

    // call split function
    std::vector<std::string> res;
    rhoban_utils::split(s, delimiter, res);

    return (vectorAreIdentical(res, words));
}

TEST(split, testSuccess) {
    std::vector<std::string> testVector;
    testVector.push_back("aaa");
    testVector.push_back("bbb");
    testVector.push_back("ccc");
    testVector.push_back("ddd");

    // test with multiple delimiter
    EXPECT_TRUE(test_split(testVector, ','));
    EXPECT_TRUE(test_split(testVector, '!'));
    EXPECT_TRUE(test_split(testVector, '"'));
    EXPECT_TRUE(test_split(testVector, 'x'));
    EXPECT_TRUE(test_split(testVector, 'y'));
    EXPECT_TRUE(test_split(testVector, 'z'));
}

TEST(split, testSuccessEmpty) {
    std::vector<std::string> testVector;

    // test with multiple delimiter
    EXPECT_TRUE(test_split(testVector, ','));
    EXPECT_TRUE(test_split(testVector, '!'));
    EXPECT_TRUE(test_split(testVector, '"'));
    EXPECT_TRUE(test_split(testVector, 'x'));
    EXPECT_TRUE(test_split(testVector, 'y'));
    EXPECT_TRUE(test_split(testVector, 'z'));
}


/*******************************************************
 * Tests rhoban_utils::file_put_contents
 */

TEST(file_put_contents, testSuccess) {
    std::string testStr = "Hello words! This is a test.";
    std::string absoluteFilePathStr = "/tmp/pfe_test_file_put_contents.txt";
    const char* absoluteFilePath = absoluteFilePathStr.c_str();

    // delete file generated by old test
    remove(absoluteFilePath);

    rhoban_utils::file_put_contents(absoluteFilePath, testStr);

    std::ifstream fin(absoluteFilePathStr);
    std::stringstream buffer;
    buffer << fin.rdbuf();
    std::string result = buffer.str();

    remove(absoluteFilePath);

    EXPECT_EQ(result, testStr);
}

/*******************************************************
 * Tests rhoban_utils::replaceAll
 */

TEST(replaceAll, testSuccess) {
    std::string source = "ababaabaa";
    std::string target = "cocoacoaa";
    std::string from = "ab";
    std::string to = "co";

    rhoban_utils::replaceAll(source, from, to);

    EXPECT_EQ(source, target);
}

TEST(replaceAll, testSuccessSourceEmpty) {
    std::string source = "";
    std::string target = "";
    std::string from = "ab";
    std::string to = "co";

    rhoban_utils::replaceAll(source, from, to);

    EXPECT_EQ(source, target);
}

TEST(replaceAll, testSuccessFromEmpty) {
    std::string source = "ababaabaa";
    std::string target = "ababaabaa";
    std::string from = "";
    std::string to = "co";

    rhoban_utils::replaceAll(source, from, to);

    EXPECT_EQ(source, target);
}

TEST(replaceAll, testSuccessToEmpty) {
    std::string source = "ababaabaa";
    std::string target = "aaa";
    std::string from = "ab";
    std::string to = "";

    rhoban_utils::replaceAll(source, from, to);

    EXPECT_EQ(source, target);
}

/*******************************************************
 * Tests rhoban_utils::strContains
 */

TEST(strContains, testSuccess) {
    std::string str = "ababaabaa";
    std::string emptyStr = "";

    // contained substr
    EXPECT_TRUE(rhoban_utils::strContains(str, "aa"));
    EXPECT_TRUE(rhoban_utils::strContains(str, ""));

    // not contains substr
    EXPECT_FALSE(rhoban_utils::strContains(str, "pp"));

    // empty str
    EXPECT_FALSE(rhoban_utils::strContains(emptyStr, "aa"));
    EXPECT_FALSE(rhoban_utils::strContains(emptyStr, "pp"));
    EXPECT_TRUE(rhoban_utils::strContains(emptyStr, ""));
}

/*******************************************************
 * Tests rhoban_utils::file_exists
 */

TEST(file_exists, testSuccess) {
    // create dynamically a file
    const std::string absoluteFilePathStr = "/tmp/pfe_test_file_exists.txt";
    const char* absoluteFilePath = absoluteFilePathStr.c_str();
    remove(absoluteFilePath);
    rhoban_utils::file_put_contents(absoluteFilePath, "Hello world");

    EXPECT_TRUE(rhoban_utils::file_exists(absoluteFilePathStr));
    EXPECT_FALSE(rhoban_utils::file_exists("ikzejofidsklnf.tutitop"));

    remove(absoluteFilePath);
}

/*******************************************************
 * Tests rhoban_utils::getBaseName
 */

TEST(getBaseName, testSuccess) {
    EXPECT_EQ(rhoban_utils::getBaseName("path/to/file.txt"), "file.txt");
    EXPECT_EQ(rhoban_utils::getBaseName("path/../../to/file.txt"), "file.txt");
    EXPECT_EQ(rhoban_utils::getBaseName("./path/to/file.txt"), "file.txt");
    EXPECT_EQ(rhoban_utils::getBaseName("/to/file.txt"), "file.txt");
    EXPECT_EQ(rhoban_utils::getBaseName("/file.txt"), "file.txt");
    EXPECT_EQ(rhoban_utils::getBaseName("file.txt"), "file.txt");
    EXPECT_EQ(rhoban_utils::getBaseName("file"), "file");
    EXPECT_EQ(rhoban_utils::getBaseName("path/to/file"), "file");
}

/*******************************************************
 * Tests rhoban_utils::getDirName
 */

TEST(getDirName, testSuccess) {
    EXPECT_EQ(rhoban_utils::getDirName("path/to/file.txt"), "path/to/");
    EXPECT_EQ(rhoban_utils::getDirName("to/file.txt"), "to/");
    EXPECT_EQ(rhoban_utils::getDirName("path/../../to/file.txt"), "path/../../to/");
    EXPECT_EQ(rhoban_utils::getDirName("./path/to/file.txt"), "./path/to/");
    EXPECT_EQ(rhoban_utils::getDirName("/to/file.txt"), "/to/");
    EXPECT_EQ(rhoban_utils::getDirName("/file.txt"), "/");
    EXPECT_EQ(rhoban_utils::getDirName("file.txt"), "./");
    EXPECT_EQ(rhoban_utils::getDirName("file"), "./");
    EXPECT_EQ(rhoban_utils::getDirName("path/to/file"), "path/to/");
}

int main(int argc, char **argv) {
    testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
