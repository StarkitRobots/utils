#include <cstdio>
#include <iostream>
#include <fstream>
#include <gtest/gtest.h>
#include <starkit_utils/util.h>

/**
 * Check if two vector of string contains same element, in same order.
 */
bool vectorAreIdentical(std::vector<std::string> vector1, std::vector<std::string> vector2)
{
  if (vector1.size() != vector2.size())
  {
    return false;
  }

  for (std::vector<int>::size_type i = 0; i < vector1.size(); i++)
  {
    if (vector1[i] != vector2[i])
    {
      return false;
    }
  }
  return true;
}

/*******************************************************
 * Tests starkit_utils::split
 */

// Return true if the split has work.
bool test_split(std::vector<std::string> words, char delimiter)
{
  std::string s = "";
  for (std::vector<int>::size_type i = 0; i < words.size(); i++)
  {
    s += words[i];
    if (i < words.size() - 1)
    {
      s += delimiter;
    }
  }

  // call split function
  std::vector<std::string> res;
  starkit_utils::split(s, delimiter, res);

  return (vectorAreIdentical(res, words));
}

TEST(split, testSuccess)
{
  std::vector<std::string> testVector;
  testVector.push_back("aaa");
  testVector.push_back("bbb");
  testVector.push_back("ccc");
  testVector.push_back("ddd");

  // test with multiple delimiter
  EXPECT_TRUE(test_split(testVector, ','));
  EXPECT_TRUE(test_split(testVector, '!'));
  EXPECT_TRUE(test_split(testVector, '"'));
  EXPECT_TRUE(test_split(testVector, 'x'));
  EXPECT_TRUE(test_split(testVector, 'y'));
  EXPECT_TRUE(test_split(testVector, 'z'));
}

TEST(split, testSuccessEmpty)
{
  std::vector<std::string> testVector;

  // test with multiple delimiter
  EXPECT_TRUE(test_split(testVector, ','));
  EXPECT_TRUE(test_split(testVector, '!'));
  EXPECT_TRUE(test_split(testVector, '"'));
  EXPECT_TRUE(test_split(testVector, 'x'));
  EXPECT_TRUE(test_split(testVector, 'y'));
  EXPECT_TRUE(test_split(testVector, 'z'));
}

/*******************************************************
 * Tests starkit_utils::file_put_contents
 */

TEST(file_put_contents, testSuccess)
{
  std::string testStr = "Hello words! This is a test.";
  std::string absoluteFilePathStr = "/tmp/pfe_test_file_put_contents.txt";
  const char* absoluteFilePath = absoluteFilePathStr.c_str();

  // delete file generated by old test
  remove(absoluteFilePath);

  starkit_utils::file_put_contents(absoluteFilePath, testStr);

  std::ifstream fin(absoluteFilePathStr);
  std::stringstream buffer;
  buffer << fin.rdbuf();
  std::string result = buffer.str();

  remove(absoluteFilePath);

  EXPECT_EQ(result, testStr);
}

/*******************************************************
 * Tests starkit_utils::replaceAll
 */

TEST(replaceAll, testSuccess)
{
  std::string source = "ababaabaa";
  std::string target = "cocoacoaa";
  std::string from = "ab";
  std::string to = "co";

  starkit_utils::replaceAll(source, from, to);

  EXPECT_EQ(source, target);
}

TEST(replaceAll, testSuccessSourceEmpty)
{
  std::string source = "";
  std::string target = "";
  std::string from = "ab";
  std::string to = "co";

  starkit_utils::replaceAll(source, from, to);

  EXPECT_EQ(source, target);
}

TEST(replaceAll, testSuccessFromEmpty)
{
  std::string source = "ababaabaa";
  std::string target = "ababaabaa";
  std::string from = "";
  std::string to = "co";

  starkit_utils::replaceAll(source, from, to);

  EXPECT_EQ(source, target);
}

TEST(replaceAll, testSuccessToEmpty)
{
  std::string source = "ababaabaa";
  std::string target = "aaa";
  std::string from = "ab";
  std::string to = "";

  starkit_utils::replaceAll(source, from, to);

  EXPECT_EQ(source, target);
}

/*******************************************************
 * Tests starkit_utils::strContains
 */

TEST(strContains, testSuccess)
{
  std::string str = "ababaabaa";
  std::string emptyStr = "";

  // contained substr
  EXPECT_TRUE(starkit_utils::strContains(str, "aa"));
  EXPECT_TRUE(starkit_utils::strContains(str, ""));

  // not contains substr
  EXPECT_FALSE(starkit_utils::strContains(str, "pp"));

  // empty str
  EXPECT_FALSE(starkit_utils::strContains(emptyStr, "aa"));
  EXPECT_FALSE(starkit_utils::strContains(emptyStr, "pp"));
  EXPECT_TRUE(starkit_utils::strContains(emptyStr, ""));
}

/*******************************************************
 * Tests starkit_utils::file_exists
 */

TEST(file_exists, testSuccess)
{
  // create dynamically a file
  const std::string absoluteFilePathStr = "/tmp/pfe_test_file_exists.txt";
  const char* absoluteFilePath = absoluteFilePathStr.c_str();
  remove(absoluteFilePath);
  starkit_utils::file_put_contents(absoluteFilePath, "Hello world");

  EXPECT_TRUE(starkit_utils::file_exists(absoluteFilePathStr));
  EXPECT_FALSE(starkit_utils::file_exists("ikzejofidsklnf.tutitop"));

  remove(absoluteFilePath);
}

/*******************************************************
 * Tests starkit_utils::getBaseName
 */

TEST(getBaseName, testSuccess)
{
  EXPECT_EQ(starkit_utils::getBaseName("path/to/file.txt"), "file.txt");
  EXPECT_EQ(starkit_utils::getBaseName("path/../../to/file.txt"), "file.txt");
  EXPECT_EQ(starkit_utils::getBaseName("./path/to/file.txt"), "file.txt");
  EXPECT_EQ(starkit_utils::getBaseName("/to/file.txt"), "file.txt");
  EXPECT_EQ(starkit_utils::getBaseName("/file.txt"), "file.txt");
  EXPECT_EQ(starkit_utils::getBaseName("file.txt"), "file.txt");
  EXPECT_EQ(starkit_utils::getBaseName("file"), "file");
  EXPECT_EQ(starkit_utils::getBaseName("path/to/file"), "file");
}

/*******************************************************
 * Tests starkit_utils::getDirName
 */

TEST(getDirName, testSuccess)
{
  EXPECT_EQ(starkit_utils::getDirName("path/to/file.txt"), "path/to/");
  EXPECT_EQ(starkit_utils::getDirName("to/file.txt"), "to/");
  EXPECT_EQ(starkit_utils::getDirName("path/../../to/file.txt"), "path/../../to/");
  EXPECT_EQ(starkit_utils::getDirName("./path/to/file.txt"), "./path/to/");
  EXPECT_EQ(starkit_utils::getDirName("/to/file.txt"), "/to/");
  EXPECT_EQ(starkit_utils::getDirName("/file.txt"), "/");
  EXPECT_EQ(starkit_utils::getDirName("file.txt"), "./");
  EXPECT_EQ(starkit_utils::getDirName("file"), "./");
  EXPECT_EQ(starkit_utils::getDirName("path/to/file"), "path/to/");
}

int main(int argc, char** argv)
{
  testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
